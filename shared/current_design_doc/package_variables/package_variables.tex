\documentclass[11pt]{report}

\usepackage{epsf,amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.0in}
\setlength{\textwidth}{6.0in}
\setlength{\evensidemargin}{0.25in}
\setlength{\oddsidemargin}{0.25in}

\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}

\lstset{
	basicstyle=\ttfamily,
		columns=fullflexible,
		showstringspaces=false,
		commentstyle=\color{gray}\upshape
}

\lstdefinelanguage{XML}
{
	morestring=[b]",
	morestring=[s]{>}{<},
	morecomment=[s]{<?}{?>},
	stringstyle=\color{black},
	identifierstyle=\color{darkblue},
	keywordstyle=\color{cyan},
	morekeywords={xmlns,version,type,name,type,dimensions,name\_in\_code,units,description,template,streams,persistence}% list your attributes here
}

\begin{document}

\title{Package Variables: \\
Requirements and Design}
\author{MPAS Development Team}

\maketitle
\tableofcontents

%-----------------------------------------------------------------------

\chapter{Summary}

This document introduces package variables, and describes requirements and
design specifications for the implementation and use of package variables.

Package variables can most easily be explained through the concept of optional
physics packages. For example, one simulation might have physics package A on
while the next might have physics package A off. During a simulation we might
not want to have all variables allocated for this physics package when it's not
being used.

As such, package variables are introduced. These are groupings of variables
whos allocation depends on the choices of namelist options. 

%-----------------------------------------------------------------------

\chapter{Requirements}

To support the increasing complexity and breadth of options in MPAS cores,
while keeping memory usage to a minimum, the package variable capability in MPAS
must meet the following requirements.

\begin{enumerate}

\item MPAS must be capable of enabling or disabling individual variables, 
   constituents of variable arrays (super-arrays), and variable groups at run-time.
   ``Enabling'' a variable means that the variable should be allocated and fully usable within
   an MPAS core; ``disabling'' means that a variable should use a little memory as possible 
   while still allowing an MPAS core to compile and run using a set of options that do not 
   require the variable. Packages are the means by which MPAS variables will be
   enabled and disabled.
   
\item It must be possible to include arbitrary sets of variables in a package. A package may, therefore,
   include a mix of regular variables, constituent variables, and variable groups. 

\item Variables are not required to belong to any package, and the behavior of variables that do
   not belong to any package should not change from current behavior in MPAS.
                                                                                                    
\item MPAS must support the ability to enable packages using arbitrary logic.

\item MPAS core and infrastructure code must be able to determine whether a variable is
   enabled or disabled.
   
\item MPAS I/O should only read/write variables and constituents that are enabled. If a variable
   is disabled, and therefore has no associated storage, reading the variable makes no sense; and
   it wouldn't appear to be useful to write garbage or default values for a variable that is never used
   during a particular execution of an MPAS core.

\item MPAS must define packages in the XML Registry files.

\item Packages must allow documentation describing the pacakge and it's intended use.

\end{enumerate}                                                             


%-----------------------------------------------------------------------

\chapter{Design and Implementation}
\section{Design: Package Variables}
Date last modified: 10/24/2013 \\
Contributors: ( Doug Jacobsen ) \\

Package variables are defined by modifying the persistence of a particular
variable. Previously variables could have their persistence defined as
persistent, or scratch, and now can additionally be defined as package.

The persistence option is added to the var\_struct, and var (nested under a
var\_array) constructs within the Registry.xml file. When persistence is
speified on a var\_struct it does not cause the entire var\_struct to be
persistent, scratch, or package, it simply defines the default persistence for
all variables defined within that particular var\_struct. This default can be
overridden by specifying the persistence on a per var, var\_array, or
constituent var basis.

Additionally, when persistence is set to package, another attribute
``package\_name'' is required. This defines the name of the package the var,
var\_struct, var\_array, or constituent var belongs to.

Packages also need to be defined. Witihin registry, at the same level as
var\_struct a new construct is created called packages. All packages must be
defined at this level before being used throughout the var\_struct groups.
Below is an example of a package definition:

{\scriptsize
\begin{lstlisting}[language=XML]
   ...
</nml_record>
<packages>
	<package name=``package_a'' description=``Description of package a''/>
	<package name=``package_b'' description=``Description of package b''/>
</packages>
<var_struct name=``mesh'' time_levs=``0''>
   ...
\end{lstlisting}
}

After the package is defined, any var\_struct, var, var\_array, or constituent
var constructs can be attached to it as follows:

{\scriptsize
\begin{lstlisting}[language=XML]
<var_struct name=``physicsA'' time_levs=``0'' persistence=``package'' package_name=``package_a''>
	<var name=``physVar1'' dimensions=``nCells Time'' .../>
</var_struct>
<var_struct name=``physicsB'' time_levs=``0''>
	<var_array name=``physVarArray'' dimensions=``nVertLevels nCells Time'' persistence=``package'' package_name=``package_b''>
		<var ... />
		...
	</var_array>
	<var array name=``physVarArray2'' dimensions=``nVertLevels nCells Time''>
		<var name=``consVar1'' persistence=``package'' package_name=``package_b'' ... />
		<var name=``consVar2'' ... />
		...
	</var_array>
</var_struct>
\end{lstlisting}
}

Within the shared framework, a module named mpas\_packages is created that
contains logicals of the format ``package\_name\_on''. These logicals are set
to ``.false.'' by default, but when set to true at the beginning of a
simulation, they enable the allocation and I/O of the package variables. 

Cores are responsible for the proper initialization of package logicals. This
is done through a routine called core\_setup\_packages, which should only have
an error argument. This subroutine is written on a per-core basis, and can
contain arbitrary logic to enable packages.

For example:
{\scriptsize
\begin{lstlisting}[language=Fortran]
subroutine mpas_core_setup_package(ierr)
  use mpas_configure

  implicit none

  integer, intent(out) :: ierr

  if(config_physics_option == trim('A')) then
    physics_a_on = .true.
  else if(config_physics_option == trim('B') .and. config_num_halos .ge. 3) then
    physics_b_on = .true.
  end if
end subroutine mpas_core_setup_packages
\end{lstlisting}
}

%-----------------------------------------------------------------------

\section{Implementation: Package Variables}
Date last modified: 10/03/2013 \\
Contributors: ( Doug Jacobsen ) \\

Package variables should be defined in registry. First a namelist option needs
to be defined that will control the package but could more generally represent
the presence of an optional physics package or portion of software. 

As an example, we will say config\_physics\_a is the namelist option we're
interested in, and we will assume this namelist option has already been defined
in registry correctly.

The first addition to Registry.xml will be the option to have:
\begin{lstlisting}
	persistence="package"
\end{lstlisting}

This option is added to the var\_struct, var\_array, and var constructs.
But not to the var construct nested under a var\_array, since individual
constituents can't be allocated within a var\_array.

When
\begin{lstlisting}
	persistence="package"
\end{lstlisting}
and two additional attributes are added to each of the constructs.
\begin{lstlisting}
	package_key="config_physics_a"
	package_value=".true."
\end{lstlisting}
where config\_physics\_a is the "package key" that controls the allocation of the construct.

Within the registry code, additional logic will be added to check if a
construct is defined as "package" or not. If it is, then additional Fortran
code will be added to the allocations and deallocations that are controlled by
the namelist parameter supplied in the package attribute.

When persistence, package\_key, and/or package\_value are set on a var\_struct,
they define the default attribute values for all var and var\_array constructs
within the var\_struct. These can be overwritten be adding persistence, 
package\_key, and/or package\_value to the individal var and var\_array constructs.

Conditional logic for using these package variables needs to be controlled by
the actual core defining/using them.

When package\_key is specified, package\_value needs to be specified as well.
If it is not specified, registry will error and fail to generate code or build
the model.

Within registry, when the parser sees a package\_key attribute, it searches
through all namelist options to find matching one. After the matching one is
found, the variable/group/variable array is linked to that namelist option.
When the Fortran code is being generated to allocate the variable, an if test
is added around the allocation that checks if the namelist options value is
equal to the package value attribute. This comparison is different depending on
the type of the namelist option. The linking described earlier occurs to allow
easy checking of the type of the namelist option to cause the comparison to
happen correctly.

The package\_value attribute is allowed to be a semicolon delimited list of
values. If the list contains multiple values, the logic generated by registry
allows the variable to be allocated if the package\_key is equal to any of the
specified package\_values. For example:
\begin{lstlisting}
	package_key="config_physics_a"
	package_value="phys1;phys2;phys3"
\end{lstlisting}

Would generate logic similar to:
\begin{lstlisting}
if(config_physics_a == trim('phys1') .or. &
   config_physics_a == trim('phys2') .or. &
   config_physics_a == trim('phys3') ) then
     allocate(var)...
end if
\end{lstlisting}

%-----------------------------------------------------------------------

\chapter{Testing}

\section{Testing and Validation: Package Variables}
Date last modified: 10/03/2013 \\
Contributors: ( Doug Jacobsen ) \\

Package variables will be added to a component.

A run with the package on and off will be performed, and then should both run
to completion and produce bit-idential results to runs where the package
variables are defined as persistent.

%-----------------------------------------------------------------------

\end{document}
