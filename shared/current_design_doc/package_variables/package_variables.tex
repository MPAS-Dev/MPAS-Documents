\documentclass[11pt]{report}

\usepackage{epsf,amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{listings}

\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.0in}
\setlength{\textwidth}{6.0in}
\setlength{\evensidemargin}{0.25in}
\setlength{\oddsidemargin}{0.25in}

\begin{document}

\title{Package Variables: \\
Requirements and Design}
\author{MPAS Development Team}

\maketitle
\tableofcontents

%-----------------------------------------------------------------------

\chapter{Summary}

This document introduces package variables, and describes requirements and
design specifications for the implementation and use of package variables.

Package variables can most easily be explained through the concept of optional
physics packages. For example, one simulation might have physics package A on
while the next might have physics package A off. During a simulation we might
not want to have all variables allocated for this physics package when it's not
being used.

As such, package variables are introduced. These are groupings of variables
whos allocation depends on the choices of namelist options. 

%-----------------------------------------------------------------------

\chapter{Requirements}

To support the increasing complexity and breadth of options in MPAS cores,
while keeping memory usage to a minimum, the package variable capability in MPAS
must meet the following requirements.

\begin{enumerate}

\item MPAS must be capable of enabling or disabling individual variables, 
   constituents of variable arrays (super-arrays), and variable groups at run-time.
   ``Enabling'' a variable means that the variable should be allocated and fully usable within
   an MPAS core; ``disabling'' means that a variable should use a little memory as possible 
   while still allowing an MPAS core to compile and run using a set of options that do not 
   require the variable. Packages are the means by which MPAS variables will be
   enabled and disabled.
   
\item It must be possible to include arbitrary sets of variables in a package. A package may, therefore,
   include a mix of regular variables, constituent variables, and variable groups. 

\item Variables are not required to belong to any package, and the behavior of variables that do
   not belong to any package should not change from current behavior in MPAS.
                                                                                                    
\item MPAS must support the ability to enable variables based on a conjunction of run-time 
   conditions (i.e., condition a {\bf and} condition b). For example, we might want to
   enable a particular variable in MPAS-A only if the user has chosen to run a digital filter initialization
   and if a certain physics option is set.
      
\item MPAS must support the ability to enable variables based on a disjunction of run-time 
   conditions (i.e., condition a {\bf or} condition b). For example, we might want to enable a
   particular variable if a physics option is set to either of several possible values, or if either of 
   two different types of options are set to particular values.
   
\item MPAS core and infrastructure code must be able to determine whether a variable is
   enabled or disabled.
   
\item MPAS I/O should only read/write variables and constituents that are enabled. If a variable
   is disabled, and therefore has no associated storage, reading the variable makes no sense; and
   it wouldn't appear to be useful to write garbage or default values for a variable that is never used
   during a particular execution of an MPAS core.

\end{enumerate}                                                             


%-----------------------------------------------------------------------

\chapter{Design and Implementation}

\section{Implementation: Package Variables}
Date last modified: 10/03/2013 \\
Contributors: ( Doug Jacobsen ) \\

Package variables should be defined in registry. First a namelist option needs
to be defined that will control the package but could more generally represent
the presence of an optional physics package or portion of software. 

As an example, we will say config\_physics\_a is the namelist option we're
interested in, and we will assume this namelist option has already been defined
in registry correctly.

The first addition to Registry.xml will be the option to have:
\begin{lstlisting}
	persistence="package"
\end{lstlisting}

This option is added to the var\_struct, var\_array, and var constructs.
But not to the var construct nested under a var\_array, since individual
constituents can't be allocated within a var\_array.

When
\begin{lstlisting}
	persistence="package"
\end{lstlisting}
and two additional attributes are added to each of the constructs.
\begin{lstlisting}
	package_key="config_physics_a"
	package_value=".true."
\end{lstlisting}
where config\_physics\_a is the "package key" that controls the allocation of the construct.

Within the registry code, additional logic will be added to check if a
construct is defined as "package" or not. If it is, then additional Fortran
code will be added to the allocations and deallocations that are controlled by
the namelist parameter supplied in the package attribute.

When persistence, package\_key, and/or package\_value are set on a var\_struct,
they define the default attribute values for all var and var\_array constructs
within the var\_struct. These can be overwritten be adding persistence, 
package\_key, and/or package\_value to the individal var and var\_array constructs.

Conditional logic for using these package variables needs to be controlled by
the actual core defining/using them.

When package\_key is specified, package\_value needs to be specified as well.
If it is not specified, registry will error and fail to generate code or build
the model.

Within registry, when the parser sees a package\_key attribute, it searches
through all namelist options to find matching one. After the matching one is
found, the variable/group/variable array is linked to that namelist option.
When the Fortran code is being generated to allocate the variable, an if test
is added around the allocation that checks if the namelist options value is
equal to the package value attribute. This comparison is different depending on
the type of the namelist option. The linking described earlier occurs to allow
easy checking of the type of the namelist option to cause the comparison to
happen correctly.

The package\_value attribute is allowed to be a semicolon delimited list of
values. If the list contains multiple values, the logic generated by registry
allows the variable to be allocated if the package\_key is equal to any of the
specified package\_values. For example:
\begin{lstlisting}
	package_key="config_physics_a"
	package_value="phys1;phys2;phys3"
\end{lstlisting}

Would generate logic similar to:
\begin{lstlisting}
if(config_physics_a == trim('phys1') .or. &
   config_physics_a == trim('phys2') .or. &
   config_physics_a == trim('phys3') ) then
     allocate(var)...
end if
\end{lstlisting}

%-----------------------------------------------------------------------

\chapter{Testing}

\section{Testing and Validation: Package Variables}
Date last modified: 10/03/2013 \\
Contributors: ( Doug Jacobsen ) \\

Package variables will be added to a component.

A run with the package on and off will be performed, and then should both run
to completion and produce bit-idential results to runs where the package
variables are defined as persistent.

%-----------------------------------------------------------------------

\end{document}
